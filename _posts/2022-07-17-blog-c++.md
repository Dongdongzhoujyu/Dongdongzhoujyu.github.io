---
title: 'c++ 基础'
date: 2022-07-17
permalink: /posts/2021/05/2021-07-17-blog-c++/
tags:
  - c++
  - stl
  - program
---


c++标准库
=====
c++包含许多正式标准，分别为 c++98, c++03, c++11(c++0x), c++14(c++1y), c++17(c++1z), c++20(c++2a), 还有正在定制中的 c++23(c++2b). 

c++版本规定了 c++ 的语法，语言特性，还规定了内置库的实现规范，即 c++ 标准库（STL）。

STL 包含了一些通用化的数据结构和算法，下面简单介绍。

### 序列式容器
- vector
- array
- deque
- list
- forward_list

### 有序关联式容器
- set
- multiset
- map
- multimap

### 无序关联式容器
- unordered_set
- unordered_multiset
- unordered_map
- unordered_multimap

### 容器适配器
- stack
- queue
- priority_queue

#### 一些共有的方法
- =: 有赋值运算符即复制构造函数
- begin(): 指向开头元素的迭代器
- end(): 指向末尾的下一个元素的迭代器，不指向元素，但指向末尾元素的后继
- rbegin(): 表示反向，rend 类似
- cbegin(): 表示 const 迭代器，cend 类似
- size(): 容器的元素个数
- max_size(): 理论存储的最大元素个数
- empty(): i是否为空
- swap(): 交换两个容器
- clear(): 清空
- 有序容器支持比较，无序容器不支持比较

迭代器
=====
### 迭代器
- 可以理解成指向容器的指针，支持自增（iter++）和解引用操（*iter）作
- 那对于无序容器来说，支持自增吗？
- 可以使用 auto 来声明
- 分类
    - input_iter, 仅支持拷贝，自增和解引用
    - output_iter, 仅支持拷贝，自增和解引用
    - forward_iter, 同时满足 input_iter 和 output_iter
    - bidirection_iter, 在 forward_iter 的基础上，支持自减
    - randomaccess_iter, 在 bidirection_iter 的基础上，支持加减运算和比较运算
- 相关函数
    - std::adcance(it, n), 将迭代器向后移动 n 步（若 n 为负数，向前移动，需要迭代器支持减操作）
    - std::next(it), 获取 it 的后继（it 不变）
    - std::next(it, n), 获取 it 的第 n 个后继（需要 it 为双向迭代器）
    - std::prev(it, n), 获取 it 的第 n 个前驱（需要 it 为双向迭代器）

vector
=====
- 构造函数

```c++
// 1. 创建空vector; 常数复杂度
vector<int> v0;
// 1+. 这句代码可以使得向vector中插入前3个元素时，保证常数时间复杂度
v0.reserve(3);
// 2. 创建一个初始空间为3的vector，其元素的默认值是0; 线性复杂度
vector<int> v1(3);
// 3. 创建一个初始空间为3的vector，其元素的默认值是2; 线性复杂度
vector<int> v2(3, 2);
// 4. 创建一个初始空间为3的vector，其元素的默认值是1，
// 并且使用v2的空间配置器; 线性复杂度
vector<int> v3(3, 1, v2.get_allocator());
// 5. 创建一个v2的拷贝vector v4， 其内容元素和v2一样; 线性复杂度
vector<int> v4(v2);
// 6. 创建一个v4的拷贝vector v5，其内容是{v4[1], v4[2]}; 线性复杂度
vector<int> v5(v4.begin() + 1, v4.begin() + 3);
// 7. 移动v2到新创建的vector v6，不发生拷贝; 常数复杂度; 需要 C++11
vector<int> v6(std::move(v2));  // 或者 v6 = std::move(v2);

```
